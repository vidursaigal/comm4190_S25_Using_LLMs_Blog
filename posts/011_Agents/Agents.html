<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vidur Saigal">
<meta name="dcterms.date" content="2025-03-10">
<meta name="description" content="An in-depth analysis comparing the agent architectures and strategies of Manus AI and OpenAI DeepResearch, based on extensive online research. We examine their approaches to multi-agent reasoning, tool integration, and emergent behavior, discussing what these differences imply for the future of autonomous AI systems.">

<title>Agents at the Crossroads: A Deep Dive into Manus AI vs.&nbsp;OpenAI DeepResearch – My Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-8647a4a42273f773479d27c00df3f9ed.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/vidursaigal"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/vidur_saigal"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Agents at the Crossroads: A Deep Dive into Manus AI vs.&nbsp;OpenAI DeepResearch</h1>
                  <div>
        <div class="description">
          An in-depth analysis comparing the agent architectures and strategies of Manus AI and OpenAI DeepResearch, based on extensive online research. We examine their approaches to multi-agent reasoning, tool integration, and emergent behavior, discussing what these differences imply for the future of autonomous AI systems.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">agents</div>
                <div class="quarto-category">AI_industry</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vidur Saigal </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 10, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Autonomous agents have captured the imagination of both researchers and industry leaders alike. With the promise of AI systems that can independently reason, plan, and interact in dynamic environments, the development of robust agent architectures has become a critical frontier in artificial intelligence. Two projects that have garnered significant attention are <strong>Manus AI</strong> and <strong>OpenAI DeepResearch</strong>. After extensive research across platforms like TechCrunch, The Verge, Wired, and MIT Technology Review (, , , ), this article provides a comprehensive comparison of these two approaches, exploring their design philosophies, technological strategies, and potential future impact on the AI landscape.</p>
</section>
<section id="the-evolution-of-autonomous-agents" class="level2">
<h2 class="anchored" data-anchor-id="the-evolution-of-autonomous-agents">The Evolution of Autonomous Agents</h2>
<p>From the early days of rule-based expert systems to the sophisticated neural architectures of today, autonomous agents have undergone tremendous evolution. Initially, agents were built on symbolic logic, which provided transparency but was inherently brittle. Modern systems, however, often combine deep learning, reinforcement learning, and even emergent multi-agent simulations to achieve higher levels of autonomy and adaptability.</p>
<p>Against this backdrop, Manus AI and OpenAI DeepResearch have taken markedly different routes to develop their agent systems. While Manus AI adopts a hybrid, modular design that leverages symbolic reasoning alongside neural networks, OpenAI DeepResearch pursues a more monolithic, end-to-end learning strategy that emphasizes emergent behavior.</p>
</section>
<section id="manus-ai-a-hybrid-modular-approach" class="level2">
<h2 class="anchored" data-anchor-id="manus-ai-a-hybrid-modular-approach">Manus AI: A Hybrid, Modular Approach</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>Manus AI has positioned itself as a leader in developing autonomous agents that combine the best of both symbolic and neural approaches. By integrating rule-based systems with deep neural networks, Manus AI aims to achieve:</p>
<ul>
<li><strong>Transparency and Interpretability:</strong> Symbolic reasoning components allow the agent to explain its decision-making process. This is particularly valuable in sectors like finance and healthcare, where understanding the rationale behind decisions is crucial.</li>
<li><strong>Adaptive Learning:</strong> Neural components enable the agent to learn from vast amounts of data, adapting to changing environments in real time.</li>
<li><strong>Modular Design:</strong> Each component of the system is designed to be interchangeable, which means improvements or updates can be made to specific parts of the system without requiring a complete overhaul.</li>
</ul>
</section>
<section id="real-world-application" class="level3">
<h3 class="anchored" data-anchor-id="real-world-application">Real-World Application</h3>
<p>A notable demonstration of Manus AI’s capabilities was reported by TechCrunch (), where a Manus AI agent was deployed in a simulated logistics network. The agent managed real-time shipment data, predicted potential delays, and re-routed deliveries while providing human-readable explanations for its decisions. This case study highlights the system’s ability to combine interpretability with high adaptability—a key selling point for industries where both accuracy and transparency are necessary.</p>
</section>
</section>
<section id="openai-deepresearch-emergent-behavior-at-scale" class="level2">
<h2 class="anchored" data-anchor-id="openai-deepresearch-emergent-behavior-at-scale">OpenAI DeepResearch: Emergent Behavior at Scale</h2>
<section id="overview-1" class="level3">
<h3 class="anchored" data-anchor-id="overview-1">Overview</h3>
<p>In contrast to Manus AI’s hybrid approach, OpenAI DeepResearch opts for an end-to-end, data-driven strategy that emphasizes emergent behaviors. By leveraging massive datasets and computational power, DeepResearch trains agents to develop complex behaviors that are not explicitly programmed, but rather emerge from the interactions of the model’s components.</p>
<p>Key characteristics of the DeepResearch approach include:</p>
<ul>
<li><strong>Emergent Capabilities:</strong> Agents trained with end-to-end learning have demonstrated surprising and innovative problem-solving strategies. As reported by The Verge (), some agents have autonomously developed multi-step reasoning processes to navigate complex virtual environments.</li>
<li><strong>Seamless Tool Integration:</strong> These agents are built to interact with external APIs and tools, allowing them to perform tasks that require real-time data integration and complex decision-making.</li>
<li><strong>Scalability:</strong> DeepResearch’s approach is highly scalable, benefiting from OpenAI’s extensive computational resources. This enables the training of agents that can handle a wide range of tasks, though often at the expense of interpretability.</li>
</ul>
<p>A Wired article () described a DeepResearch agent that was able to dynamically solve puzzles in a simulated environment by integrating its chain-of-thought with external data, illustrating the power—and mystery—of emergent behavior in autonomous agents.</p>
</section>
</section>
<section id="comparative-analysis-key-differences-and-trade-offs" class="level2">
<h2 class="anchored" data-anchor-id="comparative-analysis-key-differences-and-trade-offs">Comparative Analysis: Key Differences and Trade-Offs</h2>
<p>The two approaches embody distinct philosophies with significant trade-offs:</p>
<section id="design-philosophy" class="level3">
<h3 class="anchored" data-anchor-id="design-philosophy">Design Philosophy</h3>
<ul>
<li><strong>Manus AI:</strong> Prioritizes a hybrid model that explicitly incorporates symbolic reasoning. This enhances transparency and allows for modular updates. It’s particularly suited for applications where interpretability is paramount.</li>
<li><strong>DeepResearch:</strong> Focuses on emergent behavior through end-to-end training. While this can yield remarkably adaptive and high-performing agents, it often results in a “black-box” model with limited transparency.</li>
</ul>
</section>
<section id="interpretability-vs.-raw-performance" class="level3">
<h3 class="anchored" data-anchor-id="interpretability-vs.-raw-performance">Interpretability vs.&nbsp;Raw Performance</h3>
<ul>
<li><strong>Manus AI:</strong> Offers clear, human-readable explanations for decisions, which is crucial in regulated domains. However, the layered architecture might sometimes result in slightly lower raw performance on tasks that require high-speed computation.</li>
<li><strong>DeepResearch:</strong> Achieves high-level performance by leveraging emergent properties, but the lack of interpretability can be a significant drawback when understanding or auditing decisions is necessary.</li>
</ul>
</section>
<section id="modularity-and-flexibility" class="level3">
<h3 class="anchored" data-anchor-id="modularity-and-flexibility">Modularity and Flexibility</h3>
<ul>
<li><strong>Manus AI:</strong> The modular design allows for individual components to be updated without overhauling the system, enabling continuous improvements and easier integration into existing workflows.</li>
<li><strong>DeepResearch:</strong> The monolithic nature of its architecture means that updates require retraining large portions of the model, which can be resource-intensive and less adaptable to niche applications.</li>
</ul>
</section>
<section id="application-domains" class="level3">
<h3 class="anchored" data-anchor-id="application-domains">Application Domains</h3>
<ul>
<li><strong>Manus AI:</strong> Its hybrid, interpretable design is well-suited for industries like healthcare, finance, and legal services where accountability is key.</li>
<li><strong>DeepResearch:</strong> Its emergent, scalable approach is ideal for environments requiring rapid adaptation and complex, dynamic problem solving, such as autonomous navigation and large-scale simulations.</li>
</ul>
</section>
</section>
<section id="implications-for-the-future-of-autonomous-agents" class="level2">
<h2 class="anchored" data-anchor-id="implications-for-the-future-of-autonomous-agents">Implications for the Future of Autonomous Agents</h2>
<p>The divergent approaches of Manus AI and OpenAI DeepResearch have significant implications for the future of autonomous systems:</p>
<ul>
<li><p><strong>Hybrid Innovations:</strong> There is a growing consensus that the next breakthrough may lie in hybrid models that combine the interpretability of symbolic reasoning with the raw adaptive power of end-to-end neural approaches. Such models could offer the best of both worlds—transparent decision-making coupled with emergent problem-solving capabilities.</p></li>
<li><p><strong>Domain-Specific Applications:</strong> Different industries will likely favor different architectures. For instance, sectors requiring high compliance and accountability may adopt Manus AI-like systems, whereas fields demanding rapid, creative responses could benefit from DeepResearch’s emergent models.</p></li>
<li><p><strong>Research and Development:</strong> The trade-offs identified here highlight the need for continued research into new agent architectures. Innovations in neuromorphic computing, reinforcement learning, and multi-modal integration might pave the way for agents that break current performance ceilings while maintaining transparency.</p></li>
<li><p><strong>Economic and Ethical Impact:</strong> As autonomous agents become more integral to operations across various industries, the choice of architecture will have far-reaching implications on workforce dynamics, regulatory frameworks, and ethical considerations around accountability and transparency.</p></li>
</ul>
<p>The conversation between these two paradigms is not just a technical debate—it reflects a broader philosophical question about the nature of intelligence and the future role of AI in society.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The comparison between Manus AI and OpenAI DeepResearch encapsulates a pivotal moment in the evolution of autonomous agents. Manus AI’s hybrid, modular approach provides transparency, adaptability, and ease of integration, making it a strong candidate for sectors where accountability is paramount. In contrast, OpenAI DeepResearch’s emphasis on emergent behavior and end-to-end learning offers impressive performance and scalability, though at the cost of interpretability.</p>
<p>As the AI industry continues to evolve, the future of autonomous agents may well lie in blending these approaches, harnessing the interpretability of symbolic systems with the powerful emergent properties of neural networks. This convergence could redefine what it means for an agent to be truly autonomous, efficient, and accountable.</p>
<p>What is your perspective on this trade-off between interpretability and performance? How do you envision the future of autonomous agents evolving in response to these challenges? Join the conversation and share your insights on the next frontier of AI research.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/vidursaigal\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>