<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vidur Saigal">
<meta name="dcterms.date" content="2025-02-17">
<meta name="description" content="An in-depth exploration into how large language models interact with two types of biological data—genomic sequences and protein structure data—featuring live tests, detailed commentary, and examples of AI responses.">

<title>Decoding Life: How LLMs Tackle Genomic Sequences and Protein Structures – My Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5c67a7444eebc356e54fdce0a63e8750.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/vidursaigal"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/vidur_saigal"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Decoding Life: How LLMs Tackle Genomic Sequences and Protein Structures</h1>
                  <div>
        <div class="description">
          An in-depth exploration into how large language models interact with two types of biological data—genomic sequences and protein structure data—featuring live tests, detailed commentary, and examples of AI responses.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">biological_data</div>
                <div class="quarto-category">genomics</div>
                <div class="quarto-category">proteomics</div>
                <div class="quarto-category">AI_analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vidur Saigal </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 17, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Biological data is among the most information-rich and complex domains, with genomic sequences and protein structures forming the cornerstone of life sciences. In this post, we explore how large language models (LLMs) interact with these data types. Through detailed tests and commentary, we evaluate the LLM’s ability to analyze a genomic sequence and interpret protein structure descriptions. We provide live examples of AI responses and discuss the underlying reasoning behind these outputs.</p>
</section>
<section id="part-i-genomic-sequence-analysis" class="level2">
<h2 class="anchored" data-anchor-id="part-i-genomic-sequence-analysis">Part I: Genomic Sequence Analysis</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>Genomic sequences are strings of nucleotides (A, T, G, and C) that encode the genetic instructions for an organism. Due to their enormous length and intricate patterns, analysis often requires specialized tools. In our test, we provide a simplified DNA sequence to the LLM and ask it to identify potential gene regions, motifs, and regulatory elements.</p>
<p>While real-world sequences are far more complex, this test serves as a proxy for how the LLM applies fundamental biological rules.</p>
</section>
<section id="test-1-genomic-sequence-analysis" class="level3">
<h3 class="anchored" data-anchor-id="test-1-genomic-sequence-analysis">Test 1: Genomic Sequence Analysis</h3>
<p><strong>User Prompt:</strong></p>
<blockquote class="blockquote">
<p>“Analyze the following genomic sequence and identify any potential gene regions or motifs:”</p>
</blockquote>
<pre><code>ATGCGTACGTAGCTAGCTAGCTGACTGACCTGATGCGTAGCTAGCTAA</code></pre>
<p><strong>AI Response:</strong></p>
<blockquote class="blockquote">
<p>“The sequence begins with ‘ATG’, the canonical start codon, indicating the likely beginning of an open reading frame (ORF). Following this, the region ‘CGTACGTAGCTAGCTAGCTGACTGACCTGATG’ appears to form a coding sequence, while the ending ‘CTAA’ includes the stop codon ‘TAA’. This suggests the presence of a small gene encoding a short peptide. Additionally, the repeated motif ‘AGCT’ may indicate binding sites for regulatory proteins or other functional elements.”</p>
</blockquote>
</section>
<section id="extended-commentary-on-genomic-analysis" class="level3">
<h3 class="anchored" data-anchor-id="extended-commentary-on-genomic-analysis">Extended Commentary on Genomic Analysis</h3>
<p>This initial test shows that the AI can recognize basic genomic features such as the start codon (<code>ATG</code>) and stop codons (<code>TAA</code>, <code>TAG</code>, <code>TGA</code>). The detection of recurring motifs, like <code>AGCT</code>, hints at possible regulatory sequences. In more complex analyses, LLMs could be prompted to predict promoter regions or enhancers by providing longer sequences and additional context (for example, GC-rich regions or TATA boxes). While the AI’s response here is simplified, it demonstrates a grasp of core principles in molecular biology. #### Additional Example:</p>
<p><strong>User Prompt:</strong></p>
<blockquote class="blockquote">
<p>“Given the sequence ‘TATAAAATGCGTACGTAAGCTTAA’, identify the potential promoter region and ORF.”</p>
</blockquote>
<p><strong>AI Response:</strong></p>
<blockquote class="blockquote">
<p>“In this sequence, ‘TATAAA’ is a common promoter element known as the TATA box, which suggests that the region upstream of the gene may be involved in transcription initiation. The sequence following the TATA box starts with ‘ATG’, indicating the start of an ORF, and continues until the stop codon ‘TAA’. This layout is typical of eukaryotic genes, where promoter regions precede the coding sequence.”</p>
</blockquote>
<p>This additional example highlights the AI’s ability to distinguish between promoter elements and coding regions, a crucial aspect of gene regulation analysis.</p>
</section>
</section>
<section id="part-ii-protein-structure-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="part-ii-protein-structure-interpretation">Part II: Protein Structure Interpretation</h2>
<section id="overview-1" class="level3">
<h3 class="anchored" data-anchor-id="overview-1">Overview</h3>
<p>Proteins are intricate molecules whose functions are largely dictated by their three-dimensional structure. Their architecture includes secondary structures (alpha helices, beta sheets), as well as tertiary and quaternary arrangements. In this section, we simulate a scenario where the LLM is given a protein description and asked to analyze its structural features and infer potential functions. In real-world applications, techniques such as X-ray crystallography or cryo-electron microscopy provide detailed protein structures. Our test uses a text-based description to see how the AI applies its learned knowledge of protein biochemistry.</p>
</section>
<section id="test-2-protein-structure-analysis" class="level3">
<h3 class="anchored" data-anchor-id="test-2-protein-structure-analysis">Test 2: Protein Structure Analysis</h3>
<p><strong>User Prompt:</strong></p>
<blockquote class="blockquote">
<p>“Given the following description of a protein structure, analyze its secondary structure content and predict its potential function:”</p>
</blockquote>
<pre><code>PDB ID: 1XYZ
Description: This protein structure consists predominantly of alpha helices with a small beta-sheet domain near the C-terminus. The alpha helices form a compact bundle, and a hydrophobic core is present. A ligand-binding pocket is observed between two helical segments.</code></pre>
<p><strong>AI Response:</strong></p>
<blockquote class="blockquote">
<p>“The protein is primarily composed of alpha helices, forming a helical bundle that is characteristic of many enzymes and receptors. The presence of a small beta-sheet domain near the C-terminus likely provides structural stability or forms part of a functional site. A hydrophobic core indicates that the protein is well-folded, and the observed ligand-binding pocket suggests a role in molecular recognition or signal transduction. This structural organization is commonly found in proteins involved in catalytic activity or in cell-surface receptor functions.”</p>
</blockquote>
</section>
<section id="extended-commentary-on-protein-structure" class="level3">
<h3 class="anchored" data-anchor-id="extended-commentary-on-protein-structure">Extended Commentary on Protein Structure</h3>
<p>In this example, the AI correctly interprets the significance of secondary structure elements. The dominance of alpha helices is a typical feature in many globular proteins, while a beta-sheet, even if minor, can contribute to a protein’s stability. The identification of a hydrophobic core further confirms that the protein is likely properly folded, a key requirement for functional activity. The mention of a ligand-binding pocket is critical, as it suggests a specific role in biochemical pathways—possibly as an enzyme or receptor.</p>
<section id="additional-example" class="level4">
<h4 class="anchored" data-anchor-id="additional-example">Additional Example:</h4>
<p><strong>User Prompt:</strong></p>
<blockquote class="blockquote">
<p>“Examine a protein described as having a mix of alpha helices and beta sheets, with a significant disordered region in the middle. What can you infer about its function?”</p>
</blockquote>
<p><strong>AI Response:</strong></p>
<blockquote class="blockquote">
<p>“A protein with both ordered (alpha helices and beta sheets) and disordered regions often exhibits flexible functions, such as in signaling or regulatory processes. The structured portions can provide a stable framework, while the disordered region may facilitate interactions with multiple partners or allow for conformational changes in response to binding events. This duality is frequently observed in transcription factors and proteins involved in cellular communication, where flexibility is advantageous for interacting with diverse molecules.”</p>
</blockquote>
<p>This follow-up test shows that the AI can consider the role of intrinsic disorder in proteins—a feature that often correlates with multifunctionality and dynamic regulatory roles.</p>
</section>
</section>
</section>
<section id="discussion-and-real-world-implications" class="level2">
<h2 class="anchored" data-anchor-id="discussion-and-real-world-implications">Discussion and Real-World Implications</h2>
<p>The tests above illustrate that LLMs can engage with biological data by identifying core elements of genomic sequences and interpreting protein structure descriptions. However, several important points must be considered:</p>
<ul>
<li><p><strong>Data Simplification:</strong> Our examples use simplified sequences and structural descriptions. Real biological data is far more complex, and precise analysis requires specialized bioinformatics tools and domain expertise.</p></li>
<li><p><strong>Statistical vs.&nbsp;Mechanistic Understanding:</strong> The AI’s responses are based on statistical patterns from its training data. While it can recognize common motifs and structural elements, it does not perform mechanistic simulations or experimental validations.</p></li>
<li><p><strong>Educational Utility:</strong> Despite its limitations, the AI can serve as a useful educational tool, helping students and researchers quickly recall basic biological principles and generate hypotheses for further investigation.</p></li>
<li><p><strong>Future Enhancements:</strong> With further domain-specific training and integration with computational biology software, LLMs could become even more adept at handling real-world biological datasets, potentially serving as assistants in research and diagnostics.</p></li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Our exploration into biological data analysis has demonstrated that large language models are capable of engaging with genomic sequences and protein structure descriptions in a meaningful way. While the examples presented are simplified, they reveal that the AI can identify key biological markers and structural motifs, reflecting an underlying understanding of essential life science concepts. As we continue this series, further tests will explore additional types of biological data, such as metabolomic profiles and cellular imaging data, to assess the evolving capabilities of LLMs in the biosciences.</p>
<p>Your feedback is invaluable. What type of biological data should we explore next? Experiment with your own prompts and join the discussion!</p>
</section>
<section id="references-and-further-reading" class="level2">
<h2 class="anchored" data-anchor-id="references-and-further-reading">References and Further Reading</h2>
<ul>
<li><a href="https://www.ncbi.nlm.nih.gov/">NCBI: Genomic Sequence Analysis</a></li>
<li><a href="https://www.rcsb.org/">Protein Data Bank (PDB)</a></li>
<li>Articles on LLMs in Bioinformatics and Computational Biology</li>
</ul>
<p>For a deeper dive into biological data analysis and the potential of AI in life sciences, explore these resources.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/vidursaigal\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>